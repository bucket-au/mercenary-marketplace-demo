{"name":"Divine Ancestral Cantrip","type":"script","scope":"global","author":"ZWjsYZjKJxZUG1KI","img":"systems/pf2e/icons/features/classes/anathema(cleric).webp","command":"if(ui.activeWindow.constructor.name == 'NPCSheetPF2e') {actor = ui.activeWindow.actor} else if(canvas.tokens.controlled.map((a) => a.actor).filter((a) => a.type === \n  \"npc\").length == 1){\n  actor = canvas.tokens.controlled[0].actor\n} else{\n        ui.notifications.warn(\"You must have either an NPC character sheet open and selected, or a single NPC token selected.\");\nreturn} \n\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\n\nlet traditionalSpells = spellS.filter(e => e.system.traditions.value.includes(\"divine\"))\nlet nonFocusSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\nlet cantrips = nonFocusSpells.filter(e => e.isCantrip == true)\nlet cantripList = Object.values(cantrips).map(e => e.name).sort() \n\ndivineCantripDialog(actor).render(true)\n\nfunction divineCantripDialog(actor){\n\nlet content = `<p><strong>Character</strong> ${actor.name}<br/>`;\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>divine Cantrip: </label><select id=\"cantrip\">';\nfor (let i = 0 ; i < cantripList.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${cantripList[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\nreturn new Dialog({\n    title: \"divine Ancestral Cantrip\",\n    content: content,\n    buttons: {\n      roll: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Select\",\n        callback: () => cantripChosen= true,\n      },\n      cancel: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: \"Cancel\",\n        callback: () => cantripChosen= false,\n      },\n    },\n    default: \"Activate\",\n    close: html => {\n        if (cantripChosen) {\n            let chosenCantrip = cantripList[html.find('#cantrip')[0].value];\n            grantCantrip(chosenCantrip);\n        }\n    }\n  });\n}\n\nasync function addSpell(spellUUID, targetLevel, targetSpellcastingEntry) {\n\nvar spell = await (async()=>{\n                        const uuid = spellUUID\n                        try {\n                            return await fromUuid(uuid)\n                        } catch (error) {\n                            return console.error(error),\n                            null\n                        }\n                    }\n)();\n\n  const spellData = spell.toObject(!0);\n        spellData.system.location.value = targetSpellcastingEntry?.id;\n  if(spell.isCantrip || spell.isFocusSpell || spell.isRitual || \n     targetSpellcastingEntry?.isSpontaneous || targetSpellcastingEntry?.isInnate){\n       spellData.system.heightenedLevel = {value: Math.max(spell.level, targetLevel)}\n  };\n  return await actor.createEmbeddedDocuments(\"Item\", [spellData])\n}\n\nasync function grantCantrip(chosenCantrip){\nname = `Innate divine Casting`\nslug = 'ancestral-divine-innate-casting'\nconst newEntry = {\n                                name,   \n                                type: \"spellcastingEntry\",\n                                data: {\n                                    slug,\n                                    ability: {\n                                        value: 'cha'\n                                    },\n                                    spelldc: {\n                                        value: (2+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        dc: (10+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        mod: 0\n                                    },\n                                    tradition: {\n                                        value: \"divine\"\n                                    },\n                                    prepared: {\n                                        value: 'innate',\n                                        flexible: false\n                                    },\n                                    showUnpreparedSpells: {\n                                        value: false\n                                    },\n                                    showSlotlessLevels: {\n                                        value: false\n                                    }\n                                }\n                            };\nawait actor.createEmbeddedDocuments(\"Item\", [newEntry])\n\nvar targetSpellcastingEntry = actor.items.find(e => e.slug == \"ancestral-divine-innate-casting\")\nspellUuid = ('Compendium.pf2e.spells-srd.'+ cantrips.find(e=>e.name == chosenCantrip)._id)\nawait addSpell(spellUuid, 0, targetSpellcastingEntry)\n}","ownership":{"default":0,"bfgnTwSJe6w6fxpV":3,"ZWjsYZjKJxZUG1KI":3},"flags":{"core":{"sourceId":"Macro.INBRxWmjkSOmB4m5"}},"_stats":{"systemId":"pf2e","systemVersion":"4.5.1","coreVersion":"10.291","createdTime":1670617981080,"modifiedTime":1671630099556,"lastModifiedBy":"bfgnTwSJe6w6fxpV"},"folder":null,"sort":0,"_id":"6h2oa86ZN4xOPSQq"}
{"name":"Grant Innate Spells","type":"script","author":"ZWjsYZjKJxZUG1KI","img":"systems/pf2e/icons/features/classes/third-path-to-perfection.webp","scope":"global","command":"if(ui.activeWindow.constructor.name == 'NPCSheetPF2e') {actor = ui.activeWindow.actor} else if(canvas.tokens.controlled.map((a) => a.actor).filter((a) => a.type === \n  \"npc\").length == 1){\n  actor = canvas.tokens.controlled[0].actor\n} else{\n        ui.notifications.warn(\"You must have either an NPC character sheet open and selected, or a single NPC token selected.\");\nreturn} \n\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\n\nasync function addSpell(spellUUID, targetLevel, targetSpellcastingEntry) {\n\nvar spell = await (async()=>{\n                        const uuid = spellUUID\n                        try {\n                            return await fromUuid(uuid)\n                        } catch (error) {\n                            return console.error(error),\n                            null\n                        }\n                    }\n)();\n\n  const spellData = spell.toObject(!0);\n        spellData.system.location.value = targetSpellcastingEntry?.id;\n  if(!(spell.isCantrip || spell.isFocusSpell || spell.isRitual) &&\n     (targetSpellcastingEntry?.isSpontaneous || targetSpellcastingEntry?.isInnate)){\nspellData.system.location.heightenedLevel = Math.max(spell.level, targetLevel)\n}\n  return await actor.createEmbeddedDocuments(\"Item\", [spellData])\n}\n\n\nconst v = actor.flags?.['pf2e-mercenary-marketplace']?.grantedSpellcasting;\nfor(var i = 0; i < Object.keys(v).length; i++){\nlet traditionType = Object.keys(v)[i];\nlet keyAbility = v[traditionType].keyStat;\nname = `Innate ${traditionType.charAt(0).toUpperCase()\n  + traditionType.slice(1)} Casting`\nslug = `${traditionType}-innate-casting`\nconst newEntry = {\n                                name,\n                                type: \"spellcastingEntry\",\n                                data: {\n                                    slug,\n                                    ability: {\n                                        value: keyAbility\n                                    },\n                                    spelldc: {\n                                        value: (2+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities[keyAbility].mod),\n                                        dc: (10+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities[keyAbility].mod),\n                                        mod: 0\n                                    },\n                                    tradition: {\n                                        value: traditionType\n                                    },\n                                    prepared: {\n                                        value: 'innate',\n                                        flexible: false\n                                    },\n                                    showUnpreparedSpells: {\n                                        value: false\n                                    },\n                                    showSlotlessLevels: {\n                                        value: false\n                                    }\n                                }\n                            };\nif(!actor.items.find(e => e.slug == `${traditionType}-innate-casting`)){\nawait actor.createEmbeddedDocuments(\"Item\", [newEntry])\n}\n\nvar targetSpellcastingEntry = actor.items.find(e => e.slug == `${traditionType}-innate-casting`)\nfor(var ii = 0; ii < v[traditionType].spells.length; ii++){\n  selectedSpell = Spells.find(e=>e.name == v[traditionType].spells[ii][1])\n  spellUuid = ('Compendium.pf2e.spells-srd.'+ selectedSpell._id)\nlet targetedLevel = Math.max(selectedSpell.baseLevel, v[traditionType].spells[ii]?.[2] ?? 0) \nlet usesCurrent = actor.items.find(e => e.name == v[traditionType].spells[ii][1])?.system?.location?.uses?.max ?? 0;\nlet usesNumber = usesCurrent + (v[traditionType].spells[ii]?.[3] ?? 1);\n\nif(actor.items.find(e => e.name == v[traditionType].spells[ii][1])?.name !== selectedSpell.name && actor.items.find(e => e.name == v[traditionType].spells[ii][1])?.system?.level?.value !== targetedLevel){\nawait addSpell(spellUuid, targetedLevel, targetSpellcastingEntry)\nawait actor.items.find(e => e.name == v[traditionType].spells[ii][1]).update({\"level\":targetedLevel,\"system.location.uses.max\":usesNumber,\"system.location.uses.value\":usesNumber,\"flags.['pf2e-mercenary-marketplace'].origin\":[v[traditionType].spells[ii][0]]})\n}\n\nif(!actor.items.find(e => e.name == v[traditionType].spells[ii][1])?.flags?.['pf2e-mercenary-marketplace']?.origin.includes(v[traditionType].spells[ii][0])){\nawait actor.items.find(e => e.name == v[traditionType].spells[ii][1]).update({\"system.location.uses.max\":usesNumber,\"system.location.uses.value\":usesNumber})  \nawait actor.items.find(e => e.name == v[traditionType].spells[ii][1]).flags?.['pf2e-mercenary-marketplace']?.origin.push(v[traditionType].spells[ii][0])\n}\n}\n}","flags":{"core":{"sourceId":"Macro.P2XNPUp0CPtsCa2u"}},"ownership":{"default":0,"gp9ShIh8z5EIvTjh":3,"bfgnTwSJe6w6fxpV":3,"ZWjsYZjKJxZUG1KI":3},"_stats":{"systemId":"pf2e","systemVersion":"4.5.1","coreVersion":"10.291","createdTime":1664485372030,"modifiedTime":1671630103944,"lastModifiedBy":"bfgnTwSJe6w6fxpV"},"folder":null,"sort":0,"_id":"A36zBYLenNrDZdc6"}
{"name":"Arcane Ancestral Cantrip","type":"script","author":"ZWjsYZjKJxZUG1KI","img":"systems/pf2e/icons/spells/wish.webp","scope":"global","command":"if(ui.activeWindow.constructor.name == 'NPCSheetPF2e') {actor = ui.activeWindow.actor} else if(canvas.tokens.controlled.map((a) => a.actor).filter((a) => a.type === \n  \"npc\").length == 1){\n  actor = canvas.tokens.controlled[0].actor\n} else{\n        ui.notifications.warn(\"You must have either an NPC character sheet open and selected, or a single NPC token selected.\");\nreturn} \n\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\n\nlet traditionalSpells = spellS.filter(e => e.system.traditions.value.includes(\"arcane\"))\nlet nonFocusSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\nlet cantrips = nonFocusSpells.filter(e => e.isCantrip == true)\nlet cantripList = Object.values(cantrips).map(e => e.name).sort() \n\narcaneCantripDialog(actor).render(true)\n\nfunction arcaneCantripDialog(actor){\n\nlet content = `<p><strong>Character</strong> ${actor.name}<br/>`;\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>Arcane Cantrip: </label><select id=\"cantrip\">';\nfor (let i = 0 ; i < cantripList.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${cantripList[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\nreturn new Dialog({\n    title: \"Arcane Ancestral Cantrip\",\n    content: content,\n    buttons: {\n      roll: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Select\",\n        callback: () => cantripChosen= true,\n      },\n      cancel: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: \"Cancel\",\n        callback: () => cantripChosen= false,\n      },\n    },\n    default: \"Activate\",\n    close: html => {\n        if (cantripChosen) {\n            let chosenCantrip = cantripList[html.find('#cantrip')[0].value];\n            grantCantrip(chosenCantrip);\n        }\n    }\n  });\n}\n\nasync function addSpell(spellUUID, targetLevel, targetSpellcastingEntry) {\n\nvar spell = await (async()=>{\n                        const uuid = spellUUID\n                        try {\n                            return await fromUuid(uuid)\n                        } catch (error) {\n                            return console.error(error),\n                            null\n                        }\n                    }\n)();\n\n  const spellData = spell.toObject(!0);\n        spellData.system.location.value = targetSpellcastingEntry?.id;\n  if(spell.isCantrip || spell.isFocusSpell || spell.isRitual || \n     targetSpellcastingEntry?.isSpontaneous || targetSpellcastingEntry?.isInnate){\n       spellData.system.heightenedLevel = {value: Math.max(spell.level, targetLevel)}\n  };\n  return await actor.createEmbeddedDocuments(\"Item\", [spellData])\n}\n\nasync function grantCantrip(chosenCantrip){\nname = `Innate Arcane Casting`\nslug = 'ancestral-arcane-innate-casting'\nconst newEntry = {\n                                name,   \n                                type: \"spellcastingEntry\",\n                                data: {\n                                    slug,\n                                    ability: {\n                                        value: 'cha'\n                                    },\n                                    spelldc: {\n                                        value: (2+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        dc: (10+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        mod: 0\n                                    },\n                                    tradition: {\n                                        value: \"arcane\"\n                                    },\n                                    prepared: {\n                                        value: 'innate',\n                                        flexible: false\n                                    },\n                                    showUnpreparedSpells: {\n                                        value: false\n                                    },\n                                    showSlotlessLevels: {\n                                        value: false\n                                    }\n                                }\n                            };\nawait actor.createEmbeddedDocuments(\"Item\", [newEntry])\n\nvar targetSpellcastingEntry = actor.items.find(e => e.slug == \"ancestral-arcane-innate-casting\")\nspellUuid = ('Compendium.pf2e.spells-srd.'+ cantrips.find(e=>e.name == chosenCantrip)._id)\nawait addSpell(spellUuid, 0, targetSpellcastingEntry)\n}","flags":{"core":{"sourceId":"Macro.P2XNPUp0CPtsCa2u"}},"ownership":{"default":0,"gp9ShIh8z5EIvTjh":3,"ZWjsYZjKJxZUG1KI":3},"_stats":{"systemId":"pf2e","systemVersion":"4.5.1","coreVersion":"10.291","createdTime":1664485372030,"modifiedTime":1671630084570,"lastModifiedBy":"bfgnTwSJe6w6fxpV"},"folder":null,"sort":0,"_id":"GFc0qSPQQb7UrN06"}
{"_id":"X1a1jfoWS4EqGETN","name":"Toggle Mercenary Marketplace Vol. 1 Directory","type":"script","author":"bfgnTwSJe6w6fxpV","img":"systems/pf2e/icons/default-icons/book.svg","scope":"global","command":"const journals = await game.packs.get(\"pf2e-mercenary-marketplace-demo.mmDemo-journals\").getDocuments();\nconst hub = journals.filter(e => e.id == \"1s34nyLF4vYUxsHX\")[0]\n\nif(ui?.activeWindow?.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX' && ui?.activeWindow?.rendered && !(ui?.activeWindow?._minimized) && ui?.activeWindow?.pageIndex == 0){\nui.activeWindow.close()\n}\nelse if(Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0]?._minimized){\nObject.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].maximize();\nObject.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].bringToTop();\n}\nelse{\nhub.sheet.render(true)\nif(Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0]){Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].bringToTop();}\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.0VyBqAD52Ghuwatk"}},"ownership":{"default":0,"O3vEcApOv2XTjC9Y":3},"_stats":{"systemId":"pf2e","systemVersion":"4.0.0-beta2","coreVersion":"10.284","createdTime":1662578752184,"modifiedTime":1662594637695,"lastModifiedBy":"bfgnTwSJe6w6fxpV"}}
{"_id":"dLMmYYevbHCikFnH","name":"Generate a Random Spell List (Demo)","type":"script","author":"bfgnTwSJe6w6fxpV","img":"systems/pf2e/icons/features/classes/interrogation-methodology.webp","scope":"global","command":"var generationGo\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\nspellTraits = Spells.map(e => e.traits)\ntraitList = [];\nfor(i=0; i<spellTraits.length; i++){\ntraitList.push(...spellTraits[i])\n}\nlet uniqueTraitList = new Set(traitList)\nlet badTraits = [\"abjuration\", \"cantrip\", \"rare\", \"summoner\", \"witch\"];\nuniqueTraitList = [...uniqueTraitList].filter(el => !badTraits.includes(el)).sort().join(\", \")\n\ngenerationDialog().render(true)\n\nfunction generationDialog(){\nconst optsMaxRarity = [\"Common\", \"Uncommon\", \"Rare\"];\nconst optsMaxLevel =  [0, 1]\nconst optsTradition = [\"Arcane\",\"Divine\",\"Occult\",\"Primal\", \"Random\"]\n\nlet content = `<p><strong>Generate Random Spell List</strong> <br/>`;\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>Spellcasting Tradition: </label><select id=\"tradition\">';\nfor (let i = 0 ; i < optsTradition.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${optsTradition[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>Maximum Rarity: </label><select id=\"maxRarity\">';\nfor (let i = 0 ; i < optsMaxRarity.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${optsMaxRarity[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\ncontent += '</p>';\n  content += '<hr/>';\ncontent += '<p><label>Allowed Schools: </label>'\n content += '<form><div class=\"form-group\">';\ncontent += '<input type=\"checkbox\" id=\"abjuration\" name=\"Abjuration\">';\ncontent += '<label for=\"abjuration\">Abjuration</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"conjuration\" name=\"Conjuration\">';\ncontent += '<label for=\"conjuration\">Conjuration</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"divination\" name=\"Divination\">';\ncontent += '<label for=\"divination\">Divination</label>';\ncontent += '</input>';\ncontent += '</div>'\ncontent += '<div class=\"form-group\">';\ncontent += '<input type=\"checkbox\" id=\"enchantment\" name=\"Enchantment\">';\ncontent += '<label for=\"enchantment\">Enchantment</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"evocation\" name=\"Evocation\">';\ncontent += '<label for=\"evocation\">Evocation</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"illusion\" name=\"Illusion\">';\ncontent += '<label for=\"illusion\">Illusion</label>';\ncontent += '</input>';\ncontent += '</div>'\ncontent += '<div class=\"form-group\">';\ncontent += '<input type=\"checkbox\" id=\"necromancy\" name=\"Necromancy\">';\ncontent += '<label for=\"necromancy\">Necromancy</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"transmutation\" name=\"Transmutation\">';\ncontent += '<label for=\"transmutation\">Transmutation</label>';\ncontent += '</input>';\ncontent += '<input type=\"checkbox\" id=\"all-schools\" name=\"allSchools\">';\ncontent += '<label for=\"all-schools\">All Schools</label>';\ncontent += '</input>';\ncontent += '</div>'\ncontent += '</form>';\ncontent += '<hr/>';\ncontent += '<form><div class=\"form-group\">';\ncontent += '<label>Allow Heightened Versions of Lower Level Spells?</label>';\ncontent += '<input type=\"checkbox\" id=\"allowHeightened\" name=\"Allow_Heightened\">';\ncontent += '</input>';\ncontent += '</div></form>';\ncontent += '<hr/>';\ncontent += '<p><label>Number of Spells of Each Level to Generate: </label>'\ncontent += '<form>'\ncontent += '<div class=\"form-group\">'\ncontent += '<p><label>Cantrips:</label>'\ncontent += '<input id=\"no-cantrips\" name=\"noCantrips\" type=\"number\"/></p>'\ncontent += '<p><label>1st Level:</label>'\ncontent += '<input id=\"no-first\" name=\"noFirst\" type=\"number\"/></p>'\ncontent += '</div>'\ncontent += '</form>'\ncontent += '<hr/>'\ncontent += '<div class=\"form-group\">'\ncontent += '<p><label>Desired Traits:</label>'\ncontent += '<input title=\"Enter a list of traits separated by commas.\" id=\"allowed-traits\" name=\"aTraits\" type=\"text\"/></p>'\ncontent += '</div>'\ncontent += '</form>'\ncontent += '<hr/>'\ncontent += '<div class=\"form-group\">'\ncontent += '<p><label>Banned Traits:</label>'\ncontent += '<input title=\"Enter a list of traits separated by commas.\" id=\"banned-traits\" name=\"bTraits\" type=\"text\"/></p>'\ncontent += '</div>'\ncontent += '</form>'\ncontent += '<p><label><b>List of Accepted Traits: </b></label>'\ncontent += `${uniqueTraitList}</p>`\n\nreturn new Dialog({\n    title: \"Spell List Generator\",\n    content: content,\n    buttons: {\n      confirm: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Select\",\n        callback: () => generationGo = true,\n      },\n      cancel: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: \"Cancel\",\n        callback: () => generationGo = false,\n      },\n    },\n    default: \"Activate\",\n    close: html => {\n        if (generationGo ?? false) {\n            let selectionDetails = {tradition: optsTradition[html.find('#tradition')[0].value], maxRarity:optsMaxRarity[html.find('#maxRarity')[0].value], allowHeightened:html.find('[name=\"Allow_Heightened\"]')[0]?.checked, allowedSchools:{abjuration:html.find('[name=\"Abjuration\"]')[0]?.checked, conjuration:html.find('[name=\"Conjuration\"]')[0]?.checked, divination:html.find('[name=\"Divination\"]')[0]?.checked,\nenchantment:html.find('[name=\"Enchantment\"]')[0]?.checked,\nevocation:html.find('[name=\"Evocation\"]')[0]?.checked, illusion:html.find('[name=\"Illusion\"]')[0]?.checked,\nnecromancy:html.find('[name=\"Necromancy\"]')[0]?.checked,\ntransmutation:html.find('[name=\"Transmutation\"]')[0]?.checked,\nallSchools:html.find('[name=\"allSchools\"]')[0]?.checked},\n spellsByLvl:{0:parseInt(html.find('[name=\"noCantrips\"]').val()) || 0, 1:parseInt(html.find('[name=\"noFirst\"]').val()) || 0},  allowedTraits:html.find('[name=\"aTraits\"]').val().toLowerCase().split(/,\\s*|\\s+/), bannedTraits:html.find('[name=\"bTraits\"]').val().toLowerCase().split(/,\\s*|\\s+/)};\ngenerateSpellList(selectionDetails);\n        }\n    }\n  });\n}\n\nfunction getRndInteger(min, max) {\n  return Math.floor(Math.random() * (max - min) ) + min;\n}\n\nfunction duplicationProtection(a, list){\n const indexValue = list.findIndex( e => e.name == a.name)\n indexValue >= 0 ? list.splice(indexValue, 1):null\n}\nfunction spellList(outputUUIDs, tradition) {\n    return `\n<h1 style = \"text-align:center\">Generated ${tradition} Spell List</h1>\n\n<table class=\"pf2-table\">\n    <tr>\n        <th>Level</th>\n        <th>Spells Known</th>\n    </tr>\n    <tr>\n        <td  style=\"width: 100px;\">Cantrips</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[0]}</div></td>\n    </tr>\n    <tr>\n        <td>1st level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[1]}</div></td>\n    </tr>\n    <tr>\n        <td>2nd level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[2]}</div></td>\n    </tr>\n    <tr>\n        <td>3rd level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[3]}</div></td>\n    </tr>\n    <tr>\n        <td>4th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[4]}</div></td>\n    </tr>\n    <tr>\n        <td>5th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[5]}</div></td>\n    </tr>\n    <tr>\n        <td>6th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[6]}</div></td>\n    </tr>\n    <tr>\n        <td>7th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[7]}</div></td>\n    </tr>\n    <tr>\n        <td>8th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[8]}</div></td>\n    </tr>\n    <tr>\n        <td>9th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[9]}</div></td>\n    </tr>\n    <tr>\n        <td>10th level</td>\n        <td><div style=\"display: flex; gap:3px; flex-wrap: wrap; align-items: center;justify-content: center;\">${outputUUIDs[10]}</div></td>\n    </tr>       \n</table>\n`;\n}\n\nfunction getRandomSpells(level, tradition, number, schools, spellS, maxRarity, allowHeightened, allowedTraits, bannedTraits){\nif(number == null || number <= 0){return};\nschools = schools ?? null\n\n\nlet traditionalSpells = spellS.filter(e => e.system.traditions.value.includes(tradition))\n\nif(maxRarity != \"rare\"){\n\nif(maxRarity == \"uncommon\"){traditionalSpells = traditionalSpells.filter(e => e.system.traits.rarity != \"rare\")}\n\nif(maxRarity == \"common\"){traditionalSpells = traditionalSpells.filter(e => e.system.traits.rarity == \"common\")}\n\n}\n\nif (level > 0) {\nlet leveledSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\n\nleveledSpells = leveledSpells.filter(e => e.isCantrip == false)\n\nfor(k=0;k<bannedTraits.length;k++){\nlet unbannedSpells = bannedTraits != '' ? leveledSpells.filter(e => !e.traits.has(bannedTraits[k])) : leveledSpells\nleveledSpells = unbannedSpells\n};\n\nlet chosenLevelSpells = leveledSpells.filter(e => e.level == level)\n\nif(allowHeightened == true){\nlet lowerLevelSpells = leveledSpells.filter(e => e.level < level)\nlet heightenableSpells = lowerLevelSpells.filter(e => e.system.description.value.includes(\"Heightened\"))\nchosenLevelSpells.push(...heightenableSpells)\n}\n\nlet chosenTraitSpells = []\nfor(l=0;l<allowedTraits.length;l++){\nlet prelimTraitSpells = allowedTraits != '' ? chosenLevelSpells.filter(e => e.traits.has(allowedTraits[l])) : chosenLevelSpells\nchosenTraitSpells.push(...prelimTraitSpells)\n};\n\nlet chosenSchoolSpells = []\nfor(j=0;j<schools.length;j++){\nlet prelimSchoolSpells = schools != null ? chosenLevelSpells.filter(e => e.school == schools[j]) : chosenLevelSpells\nchosenSchoolSpells.push(...prelimSchoolSpells)\n};\n\n\nlet prelimChosenSpellsInclusive = chosenSchoolSpells\nprelimChosenSpellsInclusive.push(...chosenTraitSpells)\nlet chosenSpellsInclusive = Array.from(new Set(prelimChosenSpellsInclusive))\n\nlet chosenSpellsExclusive = []\n   for(let i = 0; i < prelimChosenSpellsInclusive.length; i++){\n      if(i === prelimChosenSpellsInclusive.lastIndexOf(prelimChosenSpellsInclusive[i])){\n         continue;\n      };\n    chosenSpellsExclusive.push(prelimChosenSpellsInclusive[i])\n   };\n\nlet outputSpells = {}\nfor(i=0; i<number; i++){\nif (chosenSpellsExclusive.length == 0){chosenSpellsExclusive = chosenTraitSpells}\nif (chosenTraitSpells.length == 0){chosenSpellsExclusive = chosenSpellsInclusive}\nif (chosenSpellsInclusive.length == 0){chosenSpellsExclusive = chosenLevelSpells}\nif (chosenLevelSpells.length == 0){ui.notifications.warn(\"Cannot generate more spells than exist in the system.\");}\nif (chosenLevelSpells.length == 1){i=number;}\nvar rndIndexValue = getRndInteger(0,chosenSpellsExclusive.length-1)\nvar selectedSpell = chosenSpellsExclusive[rndIndexValue]\nduplicationProtection(selectedSpell, chosenSpellsExclusive);\nduplicationProtection(selectedSpell, chosenTraitSpells);\nduplicationProtection(selectedSpell, chosenSpellsInclusive);\nduplicationProtection(selectedSpell, chosenLevelSpells);\noutputSpells[i] = {name:selectedSpell.name, spell:selectedSpell}\n}\nreturn outputSpells\n}\n\nelse{\nlet nonFocusSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\n\nlet cantrips = nonFocusSpells.filter(e => e.isCantrip == true)\n\nfor(k=0;k<bannedTraits.length;k++){\nlet unbannedCantrips = bannedTraits != '' ? cantrips.filter(e => !e.traits.has(bannedTraits[k])) : cantrips\ncantrips = unbannedCantrips\n};\n\nlet chosenTraitCantrips = []\nfor(l=0;l<allowedTraits.length;l++){\nlet prelimTraitCantrips = allowedTraits != '' ? cantrips.filter(e => e.traits.has(allowedTraits[l])) : cantrips\nchosenTraitCantrips.push(...prelimTraitCantrips)\n};\n\nlet chosenSchoolCantrips = []\nfor(j=0;j<schools.length;j++){\nlet prelimSchoolCantrips = schools != null ? cantrips.filter(e => e.school == schools[j]) : cantrips\nchosenSchoolCantrips.push(...prelimSchoolCantrips)\n};\n\nlet prelimChosenCantripsInclusive = chosenSchoolCantrips\nprelimChosenCantripsInclusive.push(...chosenTraitCantrips)\nlet chosenCantripsInclusive = Array.from(new Set(prelimChosenCantripsInclusive))\n\nlet chosenCantripsExclusive = []\n   for(let i = 0; i < prelimChosenCantripsInclusive.length; i++){\n      if(i === prelimChosenCantripsInclusive.lastIndexOf(prelimChosenCantripsInclusive[i])){\n         continue;\n      };\n    chosenCantripsExclusive.push(prelimChosenCantripsInclusive[i])\n   };\n\nlet outputSpells = {}\nfor(i=0; i<number; i++){\nif (chosenCantripsExclusive.length == 0){chosenCantripsExclusive = chosenTraitCantrips}\nif (chosenTraitCantrips.length == 0){chosenCantripsExclusive = chosenCantripsInclusive}\nif (chosenCantripsInclusive.length == 0){chosenCantripsExclusive = cantrips}\nif (cantrips.length == 0){ui.notifications.warn(\"Cannot generate more spells than exist in the system.\");}\nif (cantrips.length == 1){i=number;}\nvar rndIndexValue = getRndInteger(0,chosenCantripsExclusive.length-1)\nvar selectedSpell = chosenCantripsExclusive[rndIndexValue]\nduplicationProtection(selectedSpell, chosenCantripsExclusive);\nduplicationProtection(selectedSpell, chosenTraitCantrips);\nduplicationProtection(selectedSpell, chosenCantripsInclusive);\nduplicationProtection(selectedSpell, cantrips);\noutputSpells[i] = {name:selectedSpell.name, spell:selectedSpell}\n}\nreturn outputSpells\n}\n}\n\nasync function generateSpellList(selectionDetails){\nlet output = {};\nlet schools = []\nselectionDetails.allowedSchools.abjuration == true ? schools.push(\"abjuration\"): schools;\nselectionDetails.allowedSchools.conjuration == true ? schools.push(\"conjuration\"): schools;\nselectionDetails.allowedSchools.divination== true ? schools.push(\"divination\"): schools;\nselectionDetails.allowedSchools.enchantment== true ? schools.push(\"enchantment\"): schools;\nselectionDetails.allowedSchools.evocation== true ? schools.push(\"evocation\"): schools;\nselectionDetails.allowedSchools.illusion== true ? schools.push(\"illusion\"): schools;\nselectionDetails.allowedSchools.necromancy== true ? schools.push(\"necromancy\"): schools;\nselectionDetails.allowedSchools.transmutation== true ? schools.push(\"transmutation\"): schools;\nconst traditionList = [\"arcane\",\"divine\",\"occult\",\"primal\"]\nselectionDetails.tradition == \"Random\" ? selectionDetails.tradition =\ntraditionList[getRndInteger(0, traditionList.length - 1)]: selectionDetails.tradition;\n\nlet schoolList = [\"abjuration\",\"conjuration\",\"divination\",\"enchantment\",\"evocation\",\"illusion\",\"necromancy\",\"transmutation\"]\nlet rndSchool1 = schoolList[getRndInteger(0, schoolList.length - 1)]\nlet rndSchool2 = schoolList[getRndInteger(0, schoolList.length - 1)]\nlet rndSchool = [rndSchool1, rndSchool2];\n\nselectionDetails.allowedSchools.randomPair == true ? schools =\nrndSchool: schools;\nselectionDetails.allowedSchools.allSchools == true ? schools =\nschoolList: schools;\n\nfor(ii=0; ii<=10; ii++){\noutput[`level ${ii}`] = getRandomSpells(ii, selectionDetails.tradition.toLowerCase(), selectionDetails.spellsByLvl[ii], schools, spellS, selectionDetails.maxRarity.toLowerCase(), selectionDetails.allowHeightened, selectionDetails.allowedTraits, selectionDetails.bannedTraits)\nif(output.length != null){\nfor(k=0; k<selectionDetails.spellsByLvl[ii]; k++){\n duplicationProtection(output[`level ${ii}`][k],spellS)\n}\n}\n}\noutputUUIDs = {};\nfor(ff=0; ff<=10; ff++){\noutputUUIDs[ff] = output[`level ${ff}`] != undefined ? Object.values(output[`level ${ff}`]).map(e => '@Compendium[pf2e.spells-srd.' + e.spell.id + ']').join(' '): \"-\";\n}\nvar report = await TextEditor.enrichHTML(spellList(outputUUIDs, selectionDetails.tradition), {async: true});\nnew Dialog({\n        title: \"Spell List\",\n        content: report,\n        buttons: {\n      new: {\n        icon: \"<i class='fas fa-redo-alt'></i>\",\n        label: \"Restart\",\n        callback: () => generationDialog().render(true),\n      },\n      repeat: {\n        icon: \"<i class='fas fa-dice'></i>\",\n        label: \"Reroll List\",\n        callback: () => generateSpellList(selectionDetails),\n      },\n    }\n    }).render(true);\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.GTjJ9L9zZeQPHkSH"}},"ownership":{"O3vEcApOv2XTjC9Y":3},"_stats":{"systemId":"pf2e","systemVersion":"4.6.4","coreVersion":"10.291","createdTime":1662578190866,"modifiedTime":1673184899733,"lastModifiedBy":"D6WnXUtfpKtLHis5"}}
{"name":"Primal Ancestral Cantrips","type":"script","scope":"global","author":"ZWjsYZjKJxZUG1KI","img":"systems/pf2e/icons/features/classes/anathema(druid).webp","command":"if(ui.activeWindow.constructor.name == 'NPCSheetPF2e') {actor = ui.activeWindow.actor} else if(canvas.tokens.controlled.map((a) => a.actor).filter((a) => a.type === \n  \"npc\").length == 1){\n  actor = canvas.tokens.controlled[0].actor\n} else{\n        ui.notifications.warn(\"You must have either an NPC character sheet open and selected, or a single NPC token selected.\");\nreturn} \n\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\n\nlet traditionalSpells = spellS.filter(e => e.system.traditions.value.includes(\"primal\"))\nlet nonFocusSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\nlet cantrips = nonFocusSpells.filter(e => e.isCantrip == true)\nlet cantripList = Object.values(cantrips).map(e => e.name).sort() \n\nprimalCantripDialog(actor).render(true)\n\nfunction primalCantripDialog(actor){\n\nlet content = `<p><strong>Character</strong> ${actor.name}<br/>`;\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>primal Cantrip: </label><select id=\"cantrip\">';\nfor (let i = 0 ; i < cantripList.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${cantripList[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\nreturn new Dialog({\n    title: \"primal Ancestral Cantrip\",\n    content: content,\n    buttons: {\n      roll: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Select\",\n        callback: () => cantripChosen= true,\n      },\n      cancel: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: \"Cancel\",\n        callback: () => cantripChosen= false,\n      },\n    },\n    default: \"Activate\",\n    close: html => {\n        if (cantripChosen) {\n            let chosenCantrip = cantripList[html.find('#cantrip')[0].value];\n            grantCantrip(chosenCantrip);\n        }\n    }\n  });\n}\n\nasync function addSpell(spellUUID, targetLevel, targetSpellcastingEntry) {\n\nvar spell = await (async()=>{\n                        const uuid = spellUUID\n                        try {\n                            return await fromUuid(uuid)\n                        } catch (error) {\n                            return console.error(error),\n                            null\n                        }\n                    }\n)();\n\n  const spellData = spell.toObject(!0);\n        spellData.system.location.value = targetSpellcastingEntry?.id;\n  if(spell.isCantrip || spell.isFocusSpell || spell.isRitual || \n     targetSpellcastingEntry?.isSpontaneous || targetSpellcastingEntry?.isInnate){\n       spellData.system.heightenedLevel = {value: Math.max(spell.level, targetLevel)}\n  };\n  return await actor.createEmbeddedDocuments(\"Item\", [spellData])\n}\n\nasync function grantCantrip(chosenCantrip){\nname = `Innate primal Casting`\nslug = 'ancestral-primal-innate-casting'\nconst newEntry = {\n                                name,   \n                                type: \"spellcastingEntry\",\n                                data: {\n                                    slug,\n                                    ability: {\n                                        value: 'cha'\n                                    },\n                                    spelldc: {\n                                        value: (2+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        dc: (10+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        mod: 0\n                                    },\n                                    tradition: {\n                                        value: \"primal\"\n                                    },\n                                    prepared: {\n                                        value: 'innate',\n                                        flexible: false\n                                    },\n                                    showUnpreparedSpells: {\n                                        value: false\n                                    },\n                                    showSlotlessLevels: {\n                                        value: false\n                                    }\n                                }\n                            };\nawait actor.createEmbeddedDocuments(\"Item\", [newEntry])\n\nvar targetSpellcastingEntry = actor.items.find(e => e.slug == \"ancestral-primal-innate-casting\")\nspellUuid = ('Compendium.pf2e.spells-srd.'+ cantrips.find(e=>e.name == chosenCantrip)._id)\nawait addSpell(spellUuid, 0, targetSpellcastingEntry)\n}","ownership":{"default":0,"bfgnTwSJe6w6fxpV":3,"ZWjsYZjKJxZUG1KI":3},"flags":{"core":{"sourceId":"Macro.aUY6gw1Zux67YTz9"}},"_stats":{"systemId":"pf2e","systemVersion":"4.5.1","coreVersion":"10.291","createdTime":1670610851131,"modifiedTime":1671630110351,"lastModifiedBy":"bfgnTwSJe6w6fxpV"},"folder":null,"sort":0,"_id":"g5wjnIPgSqByo7Kq"}
{"name":"Occult Ancestral Cantrip","type":"script","author":"ZWjsYZjKJxZUG1KI","img":"systems/pf2e/icons/spells/alter-reality.webp","scope":"global","command":"if(ui.activeWindow.constructor.name == 'NPCSheetPF2e') {actor = ui.activeWindow.actor} else if(canvas.tokens.controlled.map((a) => a.actor).filter((a) => a.type === \n  \"npc\").length == 1){\n  actor = canvas.tokens.controlled[0].actor\n} else{\n        ui.notifications.warn(\"You must have either an NPC character sheet open and selected, or a single NPC token selected.\");\nreturn} \n\nconst spellz = await game.packs.get('pf2e.spells-srd');\nconst spellS = await spellz.getDocuments();\nconst Spells = spellS.filter(e => e.system.category.value == \"spell\")\n\nlet traditionalSpells = spellS.filter(e => e.system.traditions.value.includes(\"occult\"))\nlet nonFocusSpells = traditionalSpells.filter(e => e.system.category.value == \"spell\")\nlet cantrips = nonFocusSpells.filter(e => e.isCantrip == true)\nlet cantripList = Object.values(cantrips).map(e => e.name).sort() \n\noccultCantripDialog(actor).render(true)\n\nfunction occultCantripDialog(actor){\n\nlet content = `<p><strong>Character</strong> ${actor.name}<br/>`;\ncontent += '</p>';\n  content += '<hr/>';\n  content += '<div class=\"form-group\">';\n  content += '<p><label>Occult Cantrip: </label><select id=\"cantrip\">';\nfor (let i = 0 ; i < cantripList.length ; i++) {\n    content += `<option value='${i}'`;\n    content += `>${cantripList[i]}</option>`;\n  }\n  content += '</select></p>';\n  content += '</div>';\nreturn new Dialog({\n    title: \"Occult Ancestral Cantrip\",\n    content: content,\n    buttons: {\n      roll: {\n        icon: \"<i class='fas fa-check'></i>\",\n        label: \"Select\",\n        callback: () => cantripChosen= true,\n      },\n      cancel: {\n        icon: \"<i class='fas fa-times'></i>\",\n        label: \"Cancel\",\n        callback: () => cantripChosen= false,\n      },\n    },\n    default: \"Activate\",\n    close: html => {\n        if (cantripChosen) {\n            let chosenCantrip = cantripList[html.find('#cantrip')[0].value];\n            grantCantrip(chosenCantrip);\n        }\n    }\n  });\n}\n\nasync function addSpell(spellUUID, targetLevel, targetSpellcastingEntry) {\n\nvar spell = await (async()=>{\n                        const uuid = spellUUID\n                        try {\n                            return await fromUuid(uuid)\n                        } catch (error) {\n                            return console.error(error),\n                            null\n                        }\n                    }\n)();\n\n  const spellData = spell.toObject(!0);\n        spellData.system.location.value = targetSpellcastingEntry?.id;\n  if(spell.isCantrip || spell.isFocusSpell || spell.isRitual || \n     targetSpellcastingEntry?.isSpontaneous || targetSpellcastingEntry?.isInnate){\n       spellData.system.heightenedLevel = {value: Math.max(spell.level, targetLevel)}\n  };\n  return await actor.createEmbeddedDocuments(\"Item\", [spellData])\n}\n\nasync function grantCantrip(chosenCantrip){\nname = `Innate Occult Casting`\nslug = 'ancestral-occult-innate-casting'\nconst newEntry = {\n                                name,   \n                                type: \"spellcastingEntry\",\n                                data: {\n                                    slug,\n                                    ability: {\n                                        value: 'cha'\n                                    },\n                                    spelldc: {\n                                        value: (2+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        dc: (10+(Math.max(2,Math.ceil(1.5*Math.floor(actor.level/3))))+actor.level+actor.abilities.cha.mod),\n                                        mod: 0\n                                    },\n                                    tradition: {\n                                        value: \"occult\"\n                                    },\n                                    prepared: {\n                                        value: 'innate',\n                                        flexible: false\n                                    },\n                                    showUnpreparedSpells: {\n                                        value: false\n                                    },\n                                    showSlotlessLevels: {\n                                        value: false\n                                    }\n                                }\n                            };\nawait actor.createEmbeddedDocuments(\"Item\", [newEntry])\n\nvar targetSpellcastingEntry = actor.items.find(e => e.slug == \"ancestral-occult-innate-casting\")\nspellUuid = ('Compendium.pf2e.spells-srd.'+ cantrips.find(e=>e.name == chosenCantrip)._id)\nawait addSpell(spellUuid, 0, targetSpellcastingEntry)\n}","flags":{"core":{"sourceId":"Macro.P2XNPUp0CPtsCa2u"}},"ownership":{"default":0,"gp9ShIh8z5EIvTjh":3,"bfgnTwSJe6w6fxpV":3,"ZWjsYZjKJxZUG1KI":3},"_stats":{"systemId":"pf2e","systemVersion":"4.5.1","coreVersion":"10.291","createdTime":1664485372030,"modifiedTime":1671630107101,"lastModifiedBy":"bfgnTwSJe6w6fxpV"},"folder":null,"sort":0,"_id":"t73Cb6tJzvKwd3sI"}
{"_id":"X1a1jfoWS4EqGETN","name":"Toggle Mercenary Marketplace Demo Directory","type":"script","author":"bfgnTwSJe6w6fxpV","img":"systems/pf2e/icons/default-icons/book.svg","scope":"global","command":"const journals = await game.packs.get(\"pf2e-mercenary-marketplace-demo.mmDemo-journals\").getDocuments();\nconst hub = journals.filter(e => e.id == \"1s34nyLF4vYUxsHX\")[0]\n\nif(ui?.activeWindow?.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX' && ui?.activeWindow?.rendered && !(ui?.activeWindow?._minimized) && ui?.activeWindow?.pageIndex == 0){\nui.activeWindow.close()\n}\nelse if(Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0]?._minimized){\nObject.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].maximize();\nObject.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].bringToTop();\n}\nelse{\nhub.sheet.render(true)\nif(Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0]){Object.values(ui.windows).filter(e=>e.id == 'JournalSheetPF2e-Compendium-pf2e-mercenary-marketplace-demo-mmDemo-journals-1s34nyLF4vYUxsHX')[0].bringToTop();}\n}","folder":null,"sort":0,"flags":{"core":{"sourceId":"Macro.0VyBqAD52Ghuwatk"}},"ownership":{"default":0,"O3vEcApOv2XTjC9Y":3},"_stats":{"systemId":"pf2e","systemVersion":"4.6.7","coreVersion":"10.291","createdTime":1662578752184,"modifiedTime":1673975437732,"lastModifiedBy":"bfgnTwSJe6w6fxpV"}}
